<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
</head>
<body>
<p>
  PackedInts-classes for counting that slices the bits from the individual values into planes.
  Sample: The entries 0-3 with max values [1, 63, 60, 1020] needs ideally only needs [1, 6, 6, 10] bits to
  represent all possible values from 0 to their individual max.<br/>
  Slicing into 3 planes this can be represented with
</p>
<ul>
  <li>Plane 1: bit 0 for entry 0, 1, 2 & 3</li>
  <li>Plane 2: bit 1-5 for entry 1, 2 & 3</li>
  <li>Plane 3: bit 6-9 for entry 3</li>
</ul>
<p>
  Information Theory states that the lower memory bound for representing entries with fully random content is
  <code>log(n)</code>. With binary content, as is the case the the PakedInts structures, the bound is normally
  stated as <code>log2(n)</code>, which translates to the [1, 6, 6, 10] in the example above.<br/>
  The plane-classes comes very near to this theoretically lower limit, for the mutable part of the structures,
  but they do require an overhead. With these implementations, the overhead is about the same as the mutable
  bits themselves, so the space needed for a single entry is <code>2*log2(max)</code>. However, the non-mutable
  parts are shared between counter instances, so each extra instance will only take up very near the theoretically
  lower bound of bits.
</p>
<p>
  The price for compactness is, not surprisingly, speed. An increment in a standard counter structure with sequential
  layout takes 1 read and 1 write, both at the same meory location.<br/>

  Assuming just 1 bit/plane, the mutation of the value itself takes one such sequence per plane that is changed.
  Plane 0 is always updated on an increment, plane 1 is updated only if plane 0 already had the bit set to 1
  (probability 0.5), plane 2 is updated if plane 1 had the bit set to 1 (also probability 0.5), and so on.<br/>

  As the probabilities are conditional, for a collection of only 1-bit planes, the average number of plane-updates
  needed is 1+0.5+(0.5^2)+(0.5^3)... = 2.
  However, in order to determine the index-locations of planes above 0, a lookup in a rank-structure is needed,
  adding 2 reads for each bit that needs to be flipped, except for the ones in plane 0.
  The total average is thus <strong>4 reads and 2writes</strong>strong> at 4 different memory locations.
  Adding to this is a higher CPU-overhead to handle the bits and ranking of planes, although this is probably dwarfed
  by the memory access penalty.
</p>
</body>
</html>
